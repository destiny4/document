## 总结

1. g代表全局匹配

2. i代表忽略大小写

3. .可以匹配任意单个字符，比如c.t可以匹配cat，cit等

4. \可以忽略转义，匹配字符本身

5. “使用元字符[和]来定义一个字符集合”,“正则表达式以[ns]开头；这个集合将匹配字符n或s（但不匹配字符c或其他字符）”

6. “为了简化字符区间的定义，正则表达式提供了一个特殊的元字符——字符区间可以用-（连字符）来定义” “模式[0-9]的功能与[0123456789]完全等价”,常用区间：[A-Z] [a-z] 

   > “在定义一个字符区间的时候，一定要避免让这个区间的尾字符小于它的首字符（例如[3-1]）。这种区间是没有意义的，而且往往会让整个模式失效”
   >
   > “-（连字符）是一个特殊的元字符，作为元字符它只能用在[和]之间。在字符集合以外的地方，-只是一个普通字符，只能与-本身相匹配。因此，在正则表达式里，-字符不需要被转义”

7. 同一个字符集合里可以给出多个字符区间。比如说，下面这个模式可以匹配任何一个字母（无论大小写）或数字，但除此以外的其他字符（既不是数字也不是字母的字符）都不匹配 [A-Za-z0-9]

8. “用元字符^来表明你想对一个字符集合进行取非匹配——这与逻辑非运算很相似”

   “^是几个有着多种用途的元字符之一。只有当它出现在一个字符集合里（被放在[和]之间）并紧跟在左方括号[的后面时，它才能发挥“求非”作用。如果是在一个字符集合的外面并位于一个模式的开头，^将匹配字符串的开头”
   
9. > “前面[0-9]只匹配数字，而这里[^0-9]匹配的是任何不是数字的字符。也就是说，[ns]a[^0-9]\.xls将匹配sam.xls，但不匹配na1.xls、na2.xls或sa1.xls”
   >

10. \d 匹配数字 \w 匹配字母数字和下划线，\s匹配空白符，大写的字母代表非，即取反

11. +元字符用于重复匹配，至少匹配一个，*元字符用于重复匹配，但可以匹配0个，？元字符只能匹配一个字符或者字符集合的零次或者一次出现

12. {}是两个元字符，用于定义一个区间或者匹配字符(字符集)的次数,{3}代表重复匹配三次，{2,4}代表最少重复2次，最多重复四次，{4,}表示至少重复4次，最多重复无数次

13. *和+ 元字符后面加上？表示懒惰型匹配，即匹配到成功的就结束，开始下一次匹配

14. \b 边界。“\b匹配的是一个这样的位置，这个位置位于一个能够用来构成单词的字符（字母、数字和下划线，也就是与\w相匹配的字符）和一个不能用来构成单词的字符（也就是与\W相匹配的字符）之间”

> 边界这个含义是相对于紧贴\b这个元字符的，对于\w而言 边界就是 \W,对于\W而言，边界就是\w

15. ｜ 是正则表达式的或操作符
## 字符串边界

>  ^ 放在[]外面，字符前面，用于匹配以什么字符开头，$放在字符后面用于匹配以什么字符结尾

> ^\s*<\?xml.*\?>，“^匹配一个字符串的开头位置，所以^\s*将匹配一个字符串的开头位置和随后的零个或多个空白字符（这解决了<?xml>标签前允许有空格、制表符、换行符等空白字符的问题）。作为一个整体，模式^\s*<\?xml.*\?>不仅能正确地匹配一个位置正确的<?xml>标签，还能对合法的空白字符做出妥善处理。”

> ?m 开启分行匹配模式

## 使用子表达式

> “子表达式是一个更大的表达式的一部分；把一个表达式划分为一系列子表达式的目的是为了把那些子表达式当作一个独立元素来使用。子表达式必须用(和)括起来。”
>

栗子

```shell
“Pinging hog.forta.com [12.159.46.200]
with 32 bytes of data:”
```

> (\d{1,3}\.?){4}

## 回溯表达式

```shell
“<[hH]([1-6])>.*?</[hH]\1>”

“<[hH]([1-6])>匹配任何一级标题的开始标签，但我们这次用(和)把[1-6]括了起来，使它
成为了一个子表达式。这样一来，我们就可以在用来匹配标题结束标签的</[hH]\1>用\1来引
用这个子表达式了。子表达式([1-6])匹配数字1~6，\1只匹配与之相同的数字。这样一来，
原始文本里的<H2>This is not valid HTML</H3>就不会被匹配到了。”
```



## 前后查找

“任何一个子表达式都可以转换为一个向前查找表达式，只要给它加上一个?=前缀即可。在同
一个搜索模式里可以使用多个向前查找表达式，它们可以出现在模式里的任意位置（而不仅仅
是出现在整个模式的开头——就像你们在上面看到的那样）。”

?= ?<= 正向前后查找 查找包含子表达式的前后

?! ?<! 负向前后查找 查找不包含子表达式的前后

## 正则表达式的条件

### 回溯引用条件

```shell
“(\()?\d{3}(?(1)\)|-)\d{3}-\d{4}”

“和前面一样，(\()?也匹配一个可选的左括号，但我们这次把它用括号括起来得到了一个子表达式。
随后的\d{3}匹配一位数字的区号。(?(1)\)|-)是一个回溯引用条件，它将根据条件是否得到满足
而去匹配)或-——如果(1)存在（也就是找到了一个左括号），\)必须被匹配；否则，-必须被匹配。
这样一来，只有配对出现的括号才会被匹配；如果没有使用括号或括号不配对，电话号码中的区号
和其余数字之间的-分隔符必须被匹配”
```

### 前后查找条件

[<a data-fancybox title="rW0MY6.png" href="https://s3.ax1x.com/2020/12/25/rW0MY6.png">![rW0MY6.png](https://s3.ax1x.com/2020/12/25/rW0MY6.png)</a>](https://imgchr.com/i/rW0MY6)

[<a data-fancybox title="rW0GOH.png" href="https://s3.ax1x.com/2020/12/25/rW0GOH.png">![rW0GOH.png](https://s3.ax1x.com/2020/12/25/rW0GOH.png)</a>](https://imgchr.com/i/rW0GOH)

## JavaScript 正则规则

> “JavaScript使用命令行选项来管理全局的区分大小写搜索：g选项激活全局搜索功能，i选项让匹配操作不区分字母的大小写，这两个选项可以组合为gi。”
>

> 其他命令行选项（版本4及以后的浏览器支持）包括：m，支持多行字符串；s，支持单行字符串；x，忽略正则表达式模式里的空白字符。

> 在使用回溯引用的时候，$将返回被匹配字符串前面的所有东西，$将返回被匹配字符串后面的所有东西，$+将返回最后一个被匹配的子表达式，$&将返回被匹配到的所有东西。

> JavaScript提供了一个名为RegExp的全局对象，在执行完一个正则表达式之后，你们可以通过这个对象获得与这次执行有关的信息。

> JavaScript不支持POSIX字符类。

> JavaScript不支持\A和\Z。



